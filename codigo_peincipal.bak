/*
  Código do robo para competição interna da droid
  Luan Haickel Araujo - 2016
  
  Competição: Seguir linhas
              Pegar e selecionar bolinhas
              Chegar no centro rápido
              pegar bolinhas fora da linha
              tempo total 3mim
              limite de um cerebro
                     4 sensores
                     3 motores
*/

/*
Máquina de estado

                                                                           BRAÇO
        MOTOR

 +-----------------+                                                       +----------------+       +------------------+
 |                 |                                                       |    Inicializa  |       |     Parado       | <-----------------+
 |   Inicializar   |                                                       |                +-----> |                  |                   |
 |                 |                                                       +----------------+       +----+-------------+                   |
 +--------+--------+                                                                                     |                                 |
          |                                                                                              +---------------------+           |
          |                                                                                              V                     V           |
          v                                                                                     +--------------+       +----------------+  |
 +--------+--------+                                                                            |              |       |                |  |
 |                 |                                                                            |   Aceita     |       |   Recusar      |  |
 | ir para o centro|                                                                            |              |       |                |  |
 |                 |                                                                            +-----+--------+       +----------------+  |
 +--------+--------+                                                                                  |                                    |
          |                                                                                           |                                    |
          |                                                                                           +------------------------------------+
          v
 +--------+--------+
 |                 |
 |  Voltar para a  |
 |      trilha     |
 +--------+--------+
          |
          |
          v                                                          +-----------------------+
+---------+-------------------------------------------------+        |                       |
|                   SEGUIR A LINHA                          |        |  Procurar bolinha     |
|      +------+                                             |  +---+ |                       | <---+
|      |Frente+<----+---------------------------------+     |  |     |                       |     |
|      +--+---+     |                                 |     |  |     +-----------------------+     |
|         |         |                                 |     |  |                                   |
| +-------+         |                                 |     |  |                                   |
| |       v         |                                 |     |  |                                   |
| |  +----+---------++       +----------------+       |     |  |  +--------------------+           |
| |  | Direita leve  +------>+Direita brusco  +-------+     |  +> |                    |           |
| |  +---------------+       +----------------+       |     |     |  Decidir caminho   |           |
| |                                                   |     +---->+                    +-----------+
| |                                                   |     |     |                    |
| |  +---------------+       +----------------+       |     |     +--------------------+
| +> | Esquerda leve +------>+Esquerda brusco +-------+     |
|    +-----+---------+       +----------------+       |     |
|          |                                          |     |
|          |                                          |     |
|          +------------------------------------------+     |
|                                                           |
+-----------------------------------------------------------+





*/

/*Definicições*/
//moteore
#define ME OUT_A
#define MD OUT_C
#define MDE OUT_AC
//sensores
#define US IN_4
#define LSD IN_2
#define LSE IN_3
#define RGB IN_1
//parametros
#define POTMAX 85

/*Definições de Variáveis*/
enum type_estado_rodas{                 //maquina de estado principal das rodas
     inicializar, inicializar2,         //andar para frente até passar as linhas e regular os sensores
     calibrando,
     ir_centro                          //função para ir para o centro o mais rápido possível
};
enum type_andar {          //possíveis movimentos do robo
     nao,                  //ficar parado
     frente,               //ir para frente o mais rápido possível
     direita_leve,         //virar levemente para a direita
     direita_brusco,       //virar para a direita de forma bruca
     esquerda_leve,        //virar levemente para a esquerda
     esquerda_brusco       //virar para a esquerda de forma bruca
};
/*Declaração de Variáveis Globais*/
//estados
type_estado_rodas estado_rodas;


//flags
type_andar andar;

//potências e parametros
int potd, pote; //potencia do motor da esquerda e do motor da direita respectivamente

//dados
int vetor_calibragem[2][3][200];//vetor para mapear a resposta dos sensores de luz à resposta a 10cm de capitação de medição
int branco_d, preto_d, cinza_d, branco_e, preto_e, cinza_e, faixa_d, faixa_e;//variáveis para guardar o valor retornado pelo sensores de  para

/*Declaração das funções*/
int ang2line(float ang);//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros
void Frente(void);//função que regula as potencias dos motores para eles andarem em linha reta

/*Função Princiapal*/
task  main()
{
 /*variáveis locais*/
 int i, j;//contador
 int temp_angulo, temp_l_d, temp_l_e;//variaveis temporárias para capitar dados dos sensores;
 int i_preto_d, i_preto_e;//variaveis usadas no estado de calibragem para saber onde começa o preto
 int temp_preto_d, temp_preto_e;

 /*inicializando os estados*/
 estado_rodas = inicializar;//maquina de estados principal
 andar = nao;//inicializando parado por segurança
 
 /*setando os sensores*/
 SetSensorLight(LSD);//sensor de luz direito
 SetSensorLight(LSE);//sensor de luz direito

 while(true)//void loop
 {

  /*maquina estado do bloco de locamoção*/
  switch(estado_rodas) //switch da máquina de estados principal
  {
   case inicializar :    //estado de inicialização para a primeira iteração
        //inicializando as variáveias para o robo andar para frente
        andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
        pote = -POTMAX;  //sentando as potências iniciais como as máximas
        potd = -POTMAX;  //as potencias são negativas pois os motores estão invertidos
        ResetTachoCount(MD);//resetando o contador de giro do motor direiro
        ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo
        
        for(i=0; i<200; i++)//for para zerar o vetor de clibragem dos sensores
        {
         vetor_calibragem[0][2][i]=0;//zerando somatório do sensor da direita
         vetor_calibragem[1][2][i]=0;//zerando somatório do sensor da esquerda
        }
        
        i=0;//iniciando o contador para preencher o vetor vet_calibragem
        
        //medição inicial
        //sensor da direita
        vetor_calibragem[0][0][0]=0;
        vetor_calibragem[0][1][0]=Sensor(LSD);
        vetor_calibragem[0][2][0]++;
        //sensor da esquerda
        vetor_calibragem[1][0][0]=0;
        vetor_calibragem[1][1][0]=Sensor(LSE);
        vetor_calibragem[1][2][0]++;

        estado_rodas = inicializar2;//levando para o próximo estado
   break;  //fim do estado
   case inicializar2 : //estado de inicialização para as demais iterações
       temp_angulo = MotorTachoCount(MD);
       temp_l_d =  Sensor(LSD);
       temp_l_e =  Sensor(LSE);
       ang2line(temp_angulo);
       
       if(ang2line(temp_angulo) < 5*(i+1))//caso ainda estaja na mesma medida
       {
        //sensor da direita
        vetor_calibragem[0][1][i]+=Sensor(LSD);
        vetor_calibragem[0][2][i]++;
        //sensor da esquerda
        vetor_calibragem[1][1][i]+=Sensor(LSE);
        vetor_calibragem[1][2][i]++;
       }
       else//caso não esteja
       {
        //calcular a media anterior
        //sensor da direita
        vetor_calibragem[0][1][i] /= vetor_calibragem[0][2][i];

        //sensor da esquerda
        vetor_calibragem[1][1][i] /= vetor_calibragem[1][2][i];

        //andando uma posição
        i++;
        
        //checando se não é a ultima posição do vetor
        if(i<200)//continua fazendo medições
        {
         //salvar a primeira medida da nova posição
         //sensor da direita
         vetor_calibragem[0][0][i]=i*5;
         vetor_calibragem[0][1][0]=Sensor(LSD);
         vetor_calibragem[0][2][0]=1;
         //sensor da esquerda
         vetor_calibragem[1][0][i]=i*5;
         vetor_calibragem[1][1][0]=Sensor(LSE);
         vetor_calibragem[1][2][0]=1;
        }
        else//sai do estado
        {
         andar = nao;//prando o robo para para passar para o estado de calibração
         estado_rodas = calibrando; /******************************   MUDANÇA DE ESTADO   ***************************************/
        }
       }
   
   break; //fim do estado
   
   case calibrando : //estado para escolher os valores de claro e escuro dos sensores de luz do rubo
        //zerando os valores de media
        preto_d=0;
        preto_e=0;

        for(i=0, j=34; i<j; i++)//for para calcular a primeira média dos valores para preto
        {
         preto_d += vetor_calibragem[0][1][i];
         preto_e += vetor_calibragem[1][1][i];
        }
        i=0;
        i_preto_e = 0;
        i_preto_d = 0;
        temp_preto_d = preto_d;
        temp_preto_e = preto_e;
        while(j<200)
        {
         //andando com as médias
         temp_preto_d = temp_preto_d + vetor_calibragem[0][1][j] - vetor_calibragem[0][1][i];
         temp_preto_e = temp_preto_e + vetor_calibragem[1][1][j] - vetor_calibragem[1][1][i];
         
         if(temp_preto_d < preto_d)//checando a média atual para o caso da direta
         {
          preto_d = temp_preto_d;
          i_preto_d = i;
         }
         
         if(temp_preto_e < preto_e)//checando a média atual para o caso da esquerda
         {
          preto_e = temp_preto_e;
          i_preto_e = i;
         }
         
         i++;
         j++;
        }

        //regulando as médias
        preto_d /= 34;
        preto_e /= 34;
        
        //calculando a média do branco
        
        //direita
        for(i=0, branco_d=0; i<i_preto_d; i++)
        {
         branco_d += vetor_calibragem[0][1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_d += vetor_calibragem[0][1][i];
        }
        
        //esquerda
        for(i=0, branco_e=0; i<i_preto_e; i++)
        {
         branco_e += vetor_calibragem[1][1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_e += vetor_calibragem[1][1][i];
        }
        
        //regulando a média
        branco_d /= 166;
        branco_e /= 166;
        
        //achando o cinza
        cinza_d = (preto_d + branco_d)/2;
        cinza_e = (preto_e + branco_e)/2;
        
        //achando a faixa
        faixa_d = (branco_d - preto_d)/5;
        faixa_e = (branco_e - preto_e)/5;
        

   break;  //fim do estado

  }
  
  /*Maquina de estado do braço*/
  
  /*saida dos motores das esteiras*/
  
  /*saida do motor do braço*/
  switch(andar)
  {
   case nao: //caso seja para parar
        OnFwd(ME,0);
        OnFwd(MD,0);
   break;//fim do caso
   case frente://caso o robo deva andar para frente
       frente();//regulando os motores para andarem para frente
   break;//fim do caso
  }
  
  //atualizando a saida dos motores
  OnFwd(ME,pote);
  OnFwd(MD,potd);
  
 }
}

/*Assinaturas das funções*/
int ang2line(float ang)//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros
{
 return ((1142*ang)/360);
}

void Frente(void)//função que regula as potencias dos motores para eles andarem em linha reta
{
 if(!(MotorTachoCount(MD) == MotorTachoCount(ME)))
 {
  if(MotorTachoCount(MD) < MotorTachoCount(ME))
  {
   if(pote > POTMAX)
   {
    pote--;
   }
   else
   {
    potd++;
   }
  }
  else if(MotorTachoCount(ME) < MotorTachoCount(MD))
  {
   if(potd > POTMAX)
   {
    potd--;
   }
   else
   {
    pote++;
   }
  }
 }
}










