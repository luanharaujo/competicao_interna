/*
  Código do robo para competição interna da droid
  Luan Haickel Araujo - 2016
  Competição: Seguir linhas
              Pegar e selecionar bolinhas
              Chegar no centro rápido
              pegar bolinhas fora da linha
              tempo total 3mim
              limite de um cerebro
                     4 sensores
                     3 motores
*/

/*
Máquina de estado

                                                                           BRAÇO
        MOTOR

 +-----------------+                                                       +----------------+       +------------------+
 |                 |                                                       |    Inicializa  |       |     Parado       | <-----------------+
 |   Inicializar   |                                                       |                +-----> |                  |                   |
 |                 |                                                       +----------------+       +----+-------------+                   |
 +--------+--------+                                                                                     |                                 |
          |                                                                                              +---------------------+           |
          |                                                                                              V                     V           |
          v                                                                                     +--------------+       +----------------+  |
 +--------+--------+                                                                            |              |       |                |  |
 |                 |                                                                            |   Aceita     |       |   Recusar      |  |
 | ir para o centro|                                                                            |              |       |                |  |
 |                 |                                                                            +-----+--------+       +----------------+  |
 +--------+--------+                                                                                  |                                    |
          |                                                                                           |                                    |
          |                                                                                           +------------------------------------+
          v
 +--------+--------+
 |                 |
 |  Voltar para a  |
 |      trilha     |
 +--------+--------+
          |
          |
          v                                                          +-----------------------+
+---------+-------------------------------------------------+        |                       |
|                   SEGUIR A LINHA                          |        |  Procurar bolinha     |
|      +------+                                             |  +---+ |                       | <---+
|      |Frente+<----+---------------------------------+     |  |     |                       |     |
|      +--+---+     |                                 |     |  |     +-----------------------+     |
|         |         |                                 |     |  |                                   |
| +-------+         |                                 |     |  |                                   |
| |       v         |                                 |     |  |                                   |
| |  +----+---------++       +----------------+       |     |  |  +--------------------+           |
| |  | Direita leve  +------>+Direita brusco  +-------+     |  +> |                    |           |
| |  +---------------+       +----------------+       |     |     |  Decidir caminho   |           |
| |                                                   |     +---->+                    +-----------+
| |                                                   |     |     |                    |
| |  +---------------+       +----------------+       |     |     +--------------------+
| +> | Esquerda leve +------>+Esquerda brusco +-------+     |
|    +-----+---------+       +----------------+       |     |
|          |                                          |     |
|          |                                          |     |
|          +------------------------------------------+     |
|                                                           |
+-----------------------------------------------------------+





*/

/*Definicições*/
//moteore
#define ME OUT_A
#define MD OUT_C
#define MDE OUT_AC
//sensores
#define US IN_4
#define LSD IN_2
#define LSE IN_3
#define RGB IN_1
//parametros
#define POTMAX 85

/*Definições de Variáveis*/
enum type_estado_rodas{                 //maquina de estado principal das rodas
     inicializar, inicializar2,         //andar para frente até passar as linhas e regular os sensores
     calibrando,                        //estado para calibrar os valores dos sensores
     ir_centro,                         //função para ir para o centro o mais rápido possível
     linha                              //estado para seguir a linha
};
enum type_estado_linha{                 //sub maquina de estado para seguir a linha
     fr, fr2,                             //frente
     dl,                                //direta leve
     el,                                //esquerda leve
     db, eb                             //direita e esquerda bruso
};
enum type_andar {          //possíveis movimentos do robo
     nao,                  //ficar parado
     frente,               //ir para frente o mais rápido possível
     direita_leve,         //virar levemente para a direita
     direita_brusco,       //virar para a direita de forma bruca
     esquerda_leve,        //virar levemente para a esquerda
     esquerda_brusco       //virar para a esquerda de forma bruca
};
/*Declaração de Variáveis Globais*/
//estados
type_estado_rodas estado_rodas;
type_estado_linha estado_linha;

//variaveis da zueira  infelizmente elas são necessárias
int my_tc_d;
int my_tc_e;

//flags
type_andar andar;

//potências e parametros
int potd, pote; //potencia do motor da esquerda e do motor da direita respectivamente

//dados
int vetor_calibragem0[3][200];//vetor para mapear a resposta dos sensores de luz à resposta a 10cm de capitação de medição
int vetor_calibragem1[3][200];//vetor para mapear a resposta dos sensores de luz à resposta a 10cm de capitação de medição
int branco_d, preto_d, cinza_d, branco_e, preto_e, cinza_e, faixa_d, faixa_e;//variáveis para guardar o valor retornado pelo sensores de  para

/*Declaração das funções*/
int ang2line(int ang);//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros
void Frente(void);//função que regula as potencias dos motores para eles andarem em linha reta

/*Função Princiapal*/
task  main()
{

 OnFwd(ME,-85);
 OnFwd(MD,-85);
 //TextOut(0,LCD_LINE2,"cheguei aqui       ");
 //Wait(1000);

 /*variáveis locais*/
 int i, j;//contador
 int temp_angulo, temp_l_d, temp_l_e;//variaveis temporárias para capitar dados dos sensores;
 int i_preto_d, i_preto_e;//variaveis usadas no estado de calibragem para saber onde começa o preto
 int temp_preto_d, temp_preto_e;

 /*inicializando os estados*/
 estado_rodas = inicializar;//maquina de estados principal
 andar = nao;//inicializando parado por segurança
 
 /*setando os sensores*/
 SetSensorLight(LSD);//sensor de luz direito
 SetSensorLight(LSE);//sensor de luz direito

 while(true)//void loop
 {
  /*maquina estado do bloco de locamoção*/
  switch(estado_rodas) //switch da máquina de estados principal
  {
   case inicializar :    //estado de inicialização para a primeira iteração

        //inicializando as variáveias para o robo andar para frente
        andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
        pote = -POTMAX;  //sentando as potências iniciais como as máximas
        potd = -POTMAX;  //as potencias são negativas pois os motores estão invertidos

        my_tc_d = 0;
        my_tc_e = 0;

        ResetTachoCount(MD);//resetando o contador de giro do motor direiro
        ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo

        for(i=0; i<200; i++)//for para zerar o vetor de clibragem dos sensores
        {
         vetor_calibragem0[2][i]=0;//zerando somatório do sensor da direita
         vetor_calibragem1[2][i]=0;//zerando somatório do sensor da esquerda
        }
        

        i=0;//iniciando o contador para preencher o vetor vet_calibragem
        
        //medição inicial
        //sensor da direita
        vetor_calibragem0[0][0]=0;
        vetor_calibragem0[1][0]=Sensor(LSD);
        vetor_calibragem0[2][0]++;
        //sensor da esquerda
        vetor_calibragem1[0][0]=0;
        vetor_calibragem1[1][0]=Sensor(LSE);
        vetor_calibragem1[2][0]++;

        estado_rodas = inicializar2;//levando para o próximo estado
   break;  //fim do estado
   case inicializar2 : //estado de inicialização para as demais iterações
       andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente


       my_tc_d += MotorTachoCount(MD);
       my_tc_e += MotorTachoCount(ME);
       ResetTachoCount(MD);//resetando o contador de giro do motor direiro
       ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo


       temp_angulo = -my_tc_d;//invertendo o sinal da entrada pois o motor esta girando para "trás"
       temp_l_d =  Sensor(LSD);
       temp_l_e =  Sensor(LSE);
       
       
       if(ang2line(temp_angulo) < 5*(i+1))//caso ainda estaja na mesma medida
       {
        //sensor da direita
        vetor_calibragem0[1][i]+=Sensor(LSD);
        vetor_calibragem0[2][i]++;
        //sensor da esquerda
        vetor_calibragem1[1][i]+=Sensor(LSE);
        vetor_calibragem1[2][i]++;

       }
       else//caso não esteja
       {
        //calcular a media anterior
        //sensor da direita
        vetor_calibragem0[1][i] /= vetor_calibragem0[2][i];

        //sensor da esquerda
        vetor_calibragem1[1][i] /= vetor_calibragem1[2][i];

        //TextOut(0,LCD_LINE2,"cheguei aqui       ");
        //Wait(1000);

        //andando uma posição
        i++;
        
        //checando se não é a ultima posição do vetor
        if(i<200)//continua fazendo medições
        {
         //salvar a primeira medida da nova posição
         //sensor da direita
         vetor_calibragem0[0][i]=i*5;
         vetor_calibragem0[1][0]=Sensor(LSD);
         vetor_calibragem0[2][0]=1;
         //sensor da esquerda
         vetor_calibragem1[0][i]=i*5;
         vetor_calibragem1[1][0]=Sensor(LSE);
         vetor_calibragem1[2][0]=1;
        }
        else//sai do estado
        {
         andar = nao;//prando o robo para para passar para o estado de calibração
         estado_rodas = calibrando; /******************************   MUDANÇA DE ESTADO   ***************************************/
        }
       }
   break; //fim do estado
   
   case calibrando : //estado para escolher os valores de claro e escuro dos sensores de luz do rubo
        //zerando os valores de media
        preto_d=0;
        preto_e=0;

        for(i=0, j=34; i<j; i++)//for para calcular a primeira média dos valores para preto
        {
         preto_d += vetor_calibragem0[1][i];
         preto_e += vetor_calibragem1[1][i];
        }
        i=0;
        i_preto_e = 0;
        i_preto_d = 0;
        temp_preto_d = preto_d;
        temp_preto_e = preto_e;
        while(j<200)
        {
         //andando com as médias
         temp_preto_d = temp_preto_d + vetor_calibragem0[1][j] - vetor_calibragem0[1][i];
         temp_preto_e = temp_preto_e + vetor_calibragem1[1][j] - vetor_calibragem1[1][i];
         
         if(temp_preto_d < preto_d)//checando a média atual para o caso da direta
         {
          preto_d = temp_preto_d;
          i_preto_d = i;
         }
         
         if(temp_preto_e < preto_e)//checando a média atual para o caso da esquerda
         {
          preto_e = temp_preto_e;
          i_preto_e = i;
         }
         
         i++;
         j++;
        }

        //regulando as médias
        preto_d /= 34;
        preto_e /= 34;
        
        //calculando a média do branco
        
        //direita
        for(i=0, branco_d=0; i<i_preto_d; i++)
        {
         branco_d += vetor_calibragem0[1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_d += vetor_calibragem0[1][i];
        }
        
        //esquerda
        for(i=0, branco_e=0; i<i_preto_e; i++)
        {
         branco_e += vetor_calibragem1[1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_e += vetor_calibragem1[1][i];
        }
        
        //regulando a média
        branco_d /= 166;
        branco_e /= 166;
        
        //achando o cinza
        cinza_d = (preto_d + branco_d)/2;
        cinza_e = (preto_e + branco_e)/2;
        
        //achando a faixa
        faixa_d = (branco_d - preto_d)/5;
        faixa_e = (branco_e - preto_e)/5;
        
        estado_rodas = linha; /******************************   MUDANÇA DE ESTADO   ***************************************/
        
   break;  //fim do estado

   case linha : //estado para seguir a linha

        //escolhendo sub estado basedo na leitura dos sensores

        temp_l_d =  Sensor(LSD);
        temp_l_e =  Sensor(LSE);

        //começando pelo sensor direito
        if(temp_l_d > cinza_d+faixa_d)//sensor da direta branco
        {
          if(temp_l_e > cinza_d+faixa_e)//sensor da esquerda branco
          {
            if((estado_linha == fr) || (estado_linha == fr2))
            {
             estado_linha = fr2;
            }
            else
            {
             estado_linha = fr;
            }
          }
          else//sensor da esquerda não esta branco
          {
            if(temp_l_e < cinza_d-faixa_e)//caso seja preto
            {
             estado_linha = db;
            }
            else//sensor direta cinza
            {
             estado_linha = dl;
            }
          }
        }
        else//sensor da direta não branco
        {
         if(temp_l_d < cinza_d-faixa_d)//caso seja preto
         {
          estado_linha = eb;
         }
         else//sensor direta cinza
         {
          estado_linha = el;
         }
        }
        
        switch(estado_linha)//sub_maquina de estado para seguir a linha
        {
         case fr:
            //inicializando as variáveias para o robo andar para frente
            andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
            pote = -POTMAX;  //sentando as potências iniciais como as máximas
            potd = -POTMAX;  //as potencias são negativas pois os motores estão invertidos

            my_tc_d = 0;
            my_tc_e = 0;


            ResetTachoCount(MD);//resetando o contador de giro do motor direiro
            ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo
            
         break;//fim do subestado
         case fr2:
            andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
         break;//fim do subestado
         case dl:
            andar = direita_leve;
         break;//fim do subestado
         case db:
            andar = direita_brusco;
         break;//fim do subestado
         case el:
            andar = esquerda_leve;
         break;//fim do subestado
         case eb:
            andar = esquerda_brusco;
         break;//fim do subestado
        }
   break; //fim do estado
  }
  
  /*Maquina de estado do braço*/
  
  /*saida dos motores das esteiras*/
  
  /*saida do motor do braço*/
  switch(andar)
  {
   case nao: //caso seja para parar

        my_tc_d = 0;
        my_tc_e = 0;
        ResetTachoCount(MD);//resetando o contador de giro do motor direiro
        ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo
        OnFwd(ME,0);
        OnFwd(MD,0);
   break;//fim do caso
   case frente://caso o robo deva andar para frente
       Frente();//regulando os motores para andarem para frente
   break;//fim do caso
   case direita_leve://caso o robo fazer uma curva leve a direta
        pote = -POTMAX;
        potd = 0;
   break;//fim do caso
   case direita_brusco://caso o robo deva fazer uma curva brusca a direta
        pote = -POTMAX;
        potd = POTMAX;
   break;//fim do caso
   case esquerda_leve://caso o robo fazer uma curva leve a esquerda
        pote = 0;
        potd = -POTMAX;
   break;//fim do caso
   case esquerda_brusco://caso o robo fazer uma curva brusca a esquerda
        pote = POTMAX;
        potd = -POTMAX;
   break;//fim do caso
  }
  
  //atualizando a saida dos motores

  my_tc_d += MotorTachoCount(MD);
  my_tc_e += MotorTachoCount(ME);

  ResetTachoCount(MD);//resetando o contador de giro do motor direiro
  ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo

  OnFwd(ME,pote);
  OnFwd(MD,potd);

 }
}



/*Assinaturas das funções*/
int ang2line(int ang)//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros
{
 return ((1142*ang)/360);
}

void Frente(void)//função que regula as potencias dos motores para eles andarem em linha reta
{

 my_tc_d += MotorTachoCount(MD);
 my_tc_e += MotorTachoCount(ME);
 ResetTachoCount(MD);//resetando o contador de giro do motor direiro
 ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo

 if(!(my_tc_d == my_tc_e))
 {
  if(my_tc_d < my_tc_e)
  {
   if(pote > -POTMAX)
   {
    pote--;
   }
   else
   {
    potd++;
   }
  }
  else if(my_tc_e < my_tc_d)
  {
   if(potd > -POTMAX)
   {
    potd--;
   }
   else
   {
    pote++;
   }
  }
 }
}










