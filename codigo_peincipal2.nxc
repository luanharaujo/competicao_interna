                                                          /*
  Código do robo para competição interna da droid
  Luan Haickel Araujo - 2016
  Competição: Seguir linhas
              Pegar e selecionar bolinhas
              Chegar no centro rápido
              pegar bolinhas fora da linha
              tempo total 3mim
              limite de um cerebro
                     4 sensores
                     3 motores
*/

/*
Máquina de estado

                                                                           BRAÇO
        MOTOR

 +-----------------+                                                       +----------------+       +------------------+
 |                 |                                                       |    Inicializa  |       |     Parado       | <-----------------+
 |   Inicializar   |                                                       |                +-----> |                  |                   |
 |                 |                                                       +----------------+       +----+-------------+                   |
 +--------+--------+                                                                                     |                                 |
          |                                                                                              +---------------------+           |
          |                                                                                              V                     V           |
          v                                                                                     +--------------+       +----------------+  |
 +--------+--------+                                                                            |              |       |                |  |
 |                 |                                                                            |   Aceita     |       |   Recusar      |  |
 | ir para o centro|                                                                            |              |       |                |  |
 |                 |                                                                            +-----+--------+       +----------------+  |
 +--------+--------+                                                                                  |                                    |
          |                                                                                           |                                    |
          |                                                                                           +------------------------------------+
          v
 +--------+--------+
 |                 |
 |  Voltar para a  |
 |      trilha     |
 +--------+--------+
          |
          |
          v                                                          +-----------------------+
+---------+-------------------------------------------------+        |                       |
|                   SEGUIR A LINHA                          |        |  Procurar bolinha     |
|      +------+                                             |  +---+ |                       | <---+
|      |Frente+<----+---------------------------------+     |  |     |                       |     |
|      +--+---+     |                                 |     |  |     +-----------------------+     |
|         |         |                                 |     |  |                                   |
| +-------+         |                                 |     |  |                                   |
| |       v         |                                 |     |  |                                   |
| |  +----+---------++       +----------------+       |     |  |  +--------------------+           |
| |  | Direita leve  +------>+Direita brusco  +-------+     |  +> |                    |           |
| |  +---------------+       +----------------+       |     |     |  Decidir caminho   |           |
| |                                                   |     +---->+                    +-----------+
| |                                                   |     |     |                    |
| |  +---------------+       +----------------+       |     |     +--------------------+
| +> | Esquerda leve +------>+Esquerda brusco +-------+     |
|    +-----+---------+       +----------------+       |     |
|          |                                          |     |
|          |                                          |     |
|          +------------------------------------------+     |
|                                                           |
+-----------------------------------------------------------+





*/

/*Definicições*/
//moteore
#define ME OUT_A
#define MD OUT_C
#define MDE OUT_AC
#define MB OUT_B
//sensores
#define US IN_4
#define LSD IN_2
#define LSE IN_3
#define RGB IN_1
//parametros
#define POTMAX 90

/*Definições de Variáveis*/
enum type_estado_rodas{                 //maquina de estado principal das rodas
     inicializar, inicializar2,         //andar para frente até passar as linhas e regular os sensores
     calibrando,                        //estado para calibrar os valores dos sensores
     ir_centro,                         //função para ir para o centro o mais rápido possível
     linha,                             //estado para seguir a linha
     deboa,                              //estado adepito do diboísmo
     emergencia,
     reto
};
enum type_estado_linha{                 //sub maquina de estado para seguir a linha
     fr, fr2,                           //frente
     dl,                                //direta leve
     el,                                //esquerda leve
     db, eb,                            //direita e esquerda bruso
     re                                 //*************************************
};
enum type_andar {          //possíveis movimentos do robo
     nao,                  //ficar parado
     frente,               //ir para frente o mais rápido possível
     direita_leve,         //virar levemente para a direita
     direita_brusco,       //virar para a direita de forma bruca
     esquerda_leve,        //virar levemente para a esquerda
     esquerda_brusco,      //virar para a esquerda de forma bruca
     andar_re
};
enum type_estado_braco {   //estado do braço indemendente
     zerar,                //estado para ir para a posição de zero
     setar,                //estado para ir para a posição inicial 18 positivos a partir do zero
     aceitar,              //rotina para aceitar a bilinha
     recusar,               //estado da rotina de recusar a bolinha
     parado
};

/*
enum type_braco_zera {               //sub estados para retornar o braço ao zero
     inicia_movimento,               //começa o movimento
     espera_bater,                   //espera mater
     desliga_espera                  //deliga e espera 350ms para mudar des estado
};
*/
//****enaum que não deu certo, fazendo na mão;
#define inicia_movimento 0
#define espera_bater 1
#define desliga_espera 2

/*Declaração de Variáveis Globais*/
//estados
type_estado_rodas estado_rodas;
type_estado_linha estado_linha;
type_estado_braco estado_braco;
int subestado_braco_zerar;

//variaveis da zueira (infelizmente elas são necessárias)
int my_tc_d;
int my_tc_e;
int my_tc_b;
int espera = 0;
int flag_re;
int cont_emergencia;

//****************************************************************************************************************
int debug = 0;
//****************************************************************************************************************

//flags
type_andar andar;

//potências e parametros
int potd, pote; //potencia do motor da esquerda e do motor da direita respectivamente
int potmax = POTMAX;
int my_old_tc_b;

//dados
int vetor_calibragem0[3][200];//vetor para mapear a resposta dos sensores de luz à resposta a 10cm de capitação de medição
int vetor_calibragem1[3][200];//vetor para mapear a resposta dos sensores de luz à resposta a 10cm de capitação de medição
int branco_d, preto_d, cinza_d, branco_e, preto_e, cinza_e, faixa_d, faixa_e;//variáveis para guardar o valor retornado pelo sensores de  para

//auxiliares
unsigned long time_temp;
int temp_cor, temp_cor_red;
int temp_US;

/*Declaração das funções*/
int ang2line(int ang);//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros

/*Função Princiapal*/
task  main()
{
 /*variáveis locais*/
 int i, j;//contador
 int temp_angulo, temp_l_d, temp_l_e;//variaveis temporárias para capitar dados dos sensores;
 int i_preto_d, i_preto_e;//variaveis usadas no estado de calibragem para saber onde começa o preto
 int temp_preto_d, temp_preto_e;

 /*inicializando os estados*/
 estado_rodas = inicializar;//maquina de estados principal
 andar = nao;//inicializando parado por segurança
 estado_braco = parado;//inicializando a maquina des estados do braço independente
 flag_re = 0;

 /*setando os sensores*/
 SetSensorLight(LSD);//sensor de luz direito
 SetSensorLight(LSE);//sensor de luz esquerdo
 SetSensorColorFull(RGB);//sensor de cor RGB
 SetSensorTouch(US);

 while(true)//void loop
 {

  ///SEGURANÇA PARA ECONTRO COM OUTRO ROBO

  if(SENSOR_4 == 1)
  {
   my_tc_d = 0;
   estado_rodas = emergencia;
   andar = andar_re;
  }


  /*maquina estado do bloco de locamoção*/
  switch(estado_rodas) //switch da máquina de estados principal
  {
   case inicializar :    //estado de inicialização para a primeira iteração

        //inicializando as variáveias para o robo andar para frente
        andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente

        my_tc_d = 0;
        my_tc_e = 0;

        ResetTachoCount(MD);//resetando o contador de giro do motor direiro
        ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo

        for(i=0; i<200; i++)//for para zerar o vetor de clibragem dos sensores
        {
         vetor_calibragem0[2][i]=0;//zerando somatório do sensor da direita
         vetor_calibragem1[2][i]=0;//zerando somatório do sensor da esquerda
        }


        i=0;//iniciando o contador para preencher o vetor vet_calibragem

        //medição inicial
        //sensor da direita
        vetor_calibragem0[0][0]=0;
        vetor_calibragem0[1][0]=Sensor(LSD);
        vetor_calibragem0[2][0]++;
        //sensor da esquerda
        vetor_calibragem1[0][0]=0;
        vetor_calibragem1[1][0]=Sensor(LSE);
        vetor_calibragem1[2][0]++;

        estado_rodas = inicializar2;//levando para o próximo estado
   break;  //fim do estado
   case inicializar2 : //estado de inicialização para as demais iterações

       andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
       my_tc_d += MotorTachoCount(MD);
       my_tc_e += MotorTachoCount(ME);
       ResetTachoCount(MD);//resetando o contador de giro do motor direiro
       ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo


       temp_angulo = -my_tc_d;//invertendo o sinal da entrada pois o motor esta girando para "trás"
       temp_l_d =  Sensor(LSD);
       temp_l_e =  Sensor(LSE);


       if(ang2line(temp_angulo) < 5*(i+1))//caso ainda estaja na mesma medida
       {
        //sensor da direita
        vetor_calibragem0[1][i]+=temp_l_d;
        vetor_calibragem0[2][i]++;
        //sensor da esquerda
        vetor_calibragem1[1][i]+=temp_l_e;
        vetor_calibragem1[2][i]++;
       }
       else//caso não esteja
       {
        //calcular a media anterior
        //sensor da direita
        vetor_calibragem0[1][i] = vetor_calibragem0[1][i]/vetor_calibragem0[2][i];

        //sensor da esquerda
        vetor_calibragem1[1][i] = vetor_calibragem1[1][i]/vetor_calibragem1[2][i];

        //andando uma posição
        i++;

        //checando se não é a ultima posição do vetor
        if(i<200)//continua fazendo medições
        {
         //salvar a primeira medida da nova posição
         //sensor da direita
         vetor_calibragem0[0][i]=i*5;
         vetor_calibragem0[1][i]=temp_l_d;
         vetor_calibragem0[2][i]=1;
         //sensor da esquerda
         vetor_calibragem1[0][i]=i*5;
         vetor_calibragem1[1][i]=temp_l_e;
         vetor_calibragem1[2][i]=1;
        }
        else//sai do estado
        {
         andar = nao;//prando o robo para para passar para o estado de calibração
         estado_rodas = calibrando; /******************************   MUDANÇA DE ESTADO   ***************************************/
        }
       }
   break; //fim do estado

   case calibrando : //estado para escolher os valores de claro e escuro dos sensores de luz do rubo

        //liberando a maquina de estados do braço
        estado_braco = zerar; //************************INICIO DO MOVIMENTO CO BRACO*********************************
        subestado_braco_zerar =  inicia_movimento;

        //zerando os valores de media
        preto_d=0;
        preto_e=0;

        for(i=0, j=34; i<j; i++)//for para calcular a primeira média dos valores para preto
        {
         preto_d += vetor_calibragem0[1][i];
         preto_e += vetor_calibragem1[1][i];
        }

        i=0;
        i_preto_e = 0;
        i_preto_d = 0;
        temp_preto_d = preto_d;
        temp_preto_e = preto_e;

        while(j<200)
        {
         //andando com as médias
         temp_preto_d = temp_preto_d + vetor_calibragem0[1][j] - vetor_calibragem0[1][i];
         temp_preto_e = temp_preto_e + vetor_calibragem1[1][j] - vetor_calibragem1[1][i];

         if(temp_preto_d < preto_d)//checando a média atual para o caso da direta
         {
          preto_d = temp_preto_d;
          i_preto_d = i;
         }

         if(temp_preto_e < preto_e)//checando a média atual para o caso da esquerda
         {
          preto_e = temp_preto_e;
          i_preto_e = i;
         }

         i++;
         j++;
        }

        //regulando as médias
        preto_d /= 34;
        preto_e /= 34;

        //calculando a média do branco

        //direita
        for(i=0, branco_d=0; i<i_preto_d; i++)
        {
         branco_d += vetor_calibragem0[1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_d += vetor_calibragem0[1][i];
        }

        //esquerda
        for(i=0, branco_e=0; i<i_preto_e; i++)
        {
         branco_e += vetor_calibragem1[1][i];
        }
        for(i+=34; i<200; i++)
        {
         branco_e += vetor_calibragem1[1][i];
        }

        //regulando a média
        branco_d /= 166;
        branco_e /= 166;

        //achando o cinza
        cinza_d = (preto_d + branco_d)/2;
        cinza_e = (preto_e + branco_e)/2;

        //achando a faixa
        faixa_d = (branco_d - preto_d)/4;
        faixa_e = (branco_e - preto_e)/4;


        estado_rodas = linha; /******************************   MUDANÇA DE ESTADO   ***************************************/

   break;  //fim do estado

   case linha : //estado para seguir a linha

        //escolhendo sub estado basedo na leitura dos sensores
        potmax = 85;

        temp_l_d =  Sensor(LSD);
        temp_l_e =  Sensor(LSE);

        if((temp_l_d < cinza_d + faixa_d) && (temp_l_e < cinza_e + faixa_e))
          {
             estado_linha = re;   //ESTOU MEXENDO AQUI##############################ESTOU MEXENDO AQUI##############################ESTOU MEXENDO AQUI##############################
             flag_re = 1;
             //TextOut(0,LCD_LINE1,"Estado ré!!!");
             ResetTachoCount(MD);
             ResetTachoCount(ME);
             my_tc_d = 0;
             my_tc_e = 0;
             andar = andar_re;
          }

        if(!flag_re)               //ESTOU MEXENDO AQUI##############################ESTOU MEXENDO AQUI##############################
        {
          //começando pelo sensor direito
          if(temp_l_d > cinza_d+faixa_d)//sensor da direta branco
          {
            if(temp_l_e > cinza_d+faixa_e)//sensor da esquerda branco
            {
              if((estado_linha == fr) || (estado_linha == fr2))
              {
               estado_linha = fr2;
              }
              else
              {
               estado_linha = fr;
              }
            }
            else//sensor da esquerda não esta branco
            {
              if(temp_l_e < cinza_d-faixa_e)//caso seja preto
              {
               estado_linha = db;
              }
              else//sensor direta cinza
              {
               estado_linha = dl;
              }
            }
          }
          else//sensor da direta não branco
          {
           if(temp_l_d < cinza_d-faixa_d)//caso seja preto
           {
             estado_linha = eb;
           }
           else//sensor direta cinza  //ESTOU MEXENDO AQUI##############################ESTOU MEXENDO AQUI##############################ESTOU MEXENDO AQUI##############################
           {
            estado_linha = el;
           }
          }
        }
        else/////////////////////// IF RE!!!!
        {

        }

        switch(estado_linha)//sub_maquina de estado para seguir a linha
        {
         case fr:
            //inicializando as variáveias para o robo andar para frente
            andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
            pote = -potmax;  //sentando as potências iniciais como as máximas
            potd = -potmax;  //as potencias são negativas pois os motores estão invertidos

            my_tc_d = 0;
            my_tc_e = 0;
            ResetTachoCount(MD);//resetando o contador de giro do motor direiro
            ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo

         break;//fim do subestado
         case fr2:
            andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
         break;//fim do subestado
         case dl:
            andar = direita_leve;
         break;//fim do subestado
         case db:
            andar = direita_brusco;
         break;//fim do subestado
         case el:
            andar = esquerda_leve;
         break;//fim do subestado
         case eb:
            andar = esquerda_brusco;
         break;//fim do subestado
         case re:
              if(ang2line(my_tc_d) >= 500) //******* TAMNAHO DA RE EM DECIMOS DE MILIMETRO!!!!! TAMNAHO DA RE!!!!! TANMANHO DA RE !!!!!!!!
              {
               flag_re = 0;
              }
              else
              {
               andar = andar_re;
              }
         break;

        }
   break; //fim do estado
   case deboa:
        //faz nada, fica só de boa
        Off(MDE);
   break;
   case reto:
       andar = frente;  //"avisando" para o sistema de output que ele deve andar para frente
       pote = -potmax;  //sentando as potências iniciais como as máximas
       potd = -potmax;  //as potencias são negativas pois os motores estão invertidos
   break;
   case emergencia:
       if(ang2line(my_tc_d) >= 3000)
       {
        //Off(MDE);
        //pote = 0;
        //potd = 0;
        estado_rodas = reto;
        OnFwd(MD,POTMAX);
        OnFwd(ME,-POTMAX);
        Wait(1000);
        
        //andar = nao;
       }
   break;
  }
  /*checando a cor da bolinha*/
  /***************************/
  /***************************/
  /****** Azul     -> 2  *****/
  /****** Verde    -> 3  *****/
  /****** Vermelho -> 5  *****/
  /***************************/
  /***************************/
  /***************************/
  //SetSensorColorFull(RGB);//sensor de cor RGB

  //SetSensorColorRed(RGB);//sensor de cor RGB
  //temp_cor_red = SensorRaw(RGB);

  temp_cor = SensorValue(RGB);

  if(!espera)
  {
    if((temp_cor ==  2) || (temp_cor == 5 ))//VERMELHO
    {
         //aceita
         estado_braco = zerar;
         subestado_braco_zerar =  inicia_movimento;

    }
    else if (0==1)//VERDE
    {
         //recusa
         estado_braco = recusar;

         if(estado_rodas == linha)
         {
          estado_rodas = deboa;
         }

         while(MotorTachoCount(MB)!=0)
         {
               ResetTachoCount(MB);
         }
         OnFwd(MB,80);
    }
  }


  /*Maquina de estado do braço*/
  switch(estado_braco)
  {
   break;//fim do estado
   case zerar:
        espera = 1;
       /*submaquina de estados*/
       switch(subestado_braco_zerar)
       {
        case inicia_movimento:
            while(MotorTachoCount(MB)!=0)
            {
             ResetTachoCount(MB);
            }
            OnFwd(MB,-70);
            my_tc_b =  MotorTachoCount(MB);
            while(my_tc_b == MotorTachoCount(MB)){}//espera começa a mexer
            subestado_braco_zerar = espera_bater; //*********************************************mudança de subestado********************
            time_temp = CurrentTick();
            my_old_tc_b = my_tc_b;
            my_tc_b =  MotorTachoCount(MB);
        break;
        case espera_bater:
             if((CurrentTick() - time_temp) > 50)
             {

              my_old_tc_b = my_tc_b;
              my_tc_b =  MotorTachoCount(MB);
              if(my_old_tc_b != my_tc_b)//não bateu ainda
              {
               time_temp = CurrentTick();
              }
              else//bateu!!
              {
               //***************************************mudança de sub estado
               //DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG
               //NumOut(0,LCD_LINE1,++debug);
               //DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG***DEBUG
               Off(MB);
               subestado_braco_zerar = desliga_espera;
               time_temp = CurrentTick();
              }
             }
        break;
        case desliga_espera:
             if((CurrentTick() - time_temp) > 300)
             {
              //muda de estado *******************************************************
              //while(MotorTachoCount(MB)!=0)//zerando o tachocout com certeza
              //{
              // ResetTachoCount(MB);
              //}
              OnFwd(MB,70);
              estado_braco = setar;
             }
        break;
       }
   break;
   case setar:
       if(MotorTachoCount(MB) >= 29)
       {
        Off(MB);
        estado_braco = parado;
        espera = 0;
        if(estado_rodas == deboa)
        {
          estado_rodas = linha;
        }
       }
   break;
   case aceitar:
      //não é usado mandar direto para zerar
   break;
   case recusar:
        if(MotorTachoCount(MB) >= 30)
        {
            estado_braco = zerar;
            subestado_braco_zerar =  inicia_movimento;
            Wait(50);
        }
   break;
   case parado:
        Off(MB);
   break;

  }

  /*saida dos motores das braço*/


  /*saida do motor do esteiras*/
  switch(andar)
  {
   case nao: //caso seja para parar

        my_tc_d = 0;
        my_tc_e = 0;
        ResetTachoCount(MD);//resetando o contador de giro do motor direiro
        ResetTachoCount(ME);//resetando o contador de giro do motor esquerdo
        OnFwd(ME,0);
        OnFwd(MD,0);
   break;//fim do caso
   case frente://caso o robo deva andar para frente
       //Frente();//regulando os motores para andarem para frente
       pote = -potmax;
       potd = -potmax;
   break;//fim do caso
   case direita_leve://caso o robo fazer uma curva leve a direta
        pote = -potmax;
        potd = 0;
   break;//fim do caso
   case direita_brusco://caso o robo deva fazer uma curva brusca a direta
        pote = -potmax;
        potd = potmax;
   break;//fim do caso
   case esquerda_leve://caso o robo fazer uma curva leve a esquerda
        pote = 0;
        potd = -potmax;
   break;//fim do caso
   case esquerda_brusco://caso o robo fazer uma curva brusca a esquerda
        pote = potmax;
        potd = -potmax;
   break;//fim do caso
   case andar_re:
        pote = potmax;
        potd = potmax;
   break;
  }

  //atualizando a saida dos motores

  my_tc_d += MotorTachoCount(MD);
  my_tc_e += MotorTachoCount(ME);

  OnFwd(ME,pote);
  OnFwd(MD,potd);

 }
}

/*Assinaturas das funções*/
int ang2line(int ang)//função que recebe uma variação angular das rodas e retornar a distancia percorrida em unidades de 10^(-7) metros
{
 return ((1142*ang)/360);
}


